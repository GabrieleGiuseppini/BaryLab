- Walking rearc attempt:
	+ Step 1: replace voluntary displacement *superimposed* with normal force, on primary only
		+ Kinda work - but secondary acquires more velocity than primary, because primary has friction
	+ Step 2: Merge CalculateTraj with StepSimulation
		+ Each Update...() step moves a segment and sets velocity based on movement achieved in its remainingDt
		= Issue at ConstrainedSegmentMove:
			! If we hit edge before end of a trajectory which is completely due to mesh movement, the particle position
			  changes as it's a temporary one; at the next iteration, trajectory is zero hence we don't move
				! We should then not update particle position and continue with the loop
			+ Solution: UpdateNpcParticle_ConstrainedTraceSegment2() works completely on bary coords - it updates them at each step; only sets position at end moments (when it has fully consumed time quantum)
				! Thoughts: UpdateNpcParticle_ConstrainedInertial2() recalculates each time target bary coords after physics delta pos (which, TODO: does it change or not? should not change
				  for the rest of this plan to work); the current bary coords change each time
				+ Loop for deltaT
					+ Note: if we allow to loop over multiple constrained sub-loops, then meshDisplacement/Velocity calculated at first step - before various coords are changed - must be constant
					  for all the other sub-loops
					+ Case 1
					+ Case 2, 3 (Constrained): UpdateNpcParticle_ConstrainedTraceSegment2()
						+ Trajectory: first particles moves with mesh (start traj) and then we try to reach start abs pos + physics delta pos (which might be zero)
						+ Takes:
							+ TrajectoryStartBaryCoords (==current bary coords; once converted to absolute, are due exclusively to mesh displacement)
							+ (Start absolute coords are implicitly TrajectoryStartBaryCoords converted to absolute)
							+ TrajectoryEndBaryCoords (==bary coords (after mesh displacement) of startPos + physicsDeltaPos)
							+ TrajectoryEndAbsoluteCoords (==startPos + physicsDeltaPos)
							+ MeshDisplacement - but TODO: remaining portion? or whole?
						+ Loops until one of three exit conditions, at which point sets physics and calculates remaining DT
							+ Reaching destination:
								! We consume the whole time quantum
								+ Set CurrentBaryCoords to TrajectoryEndBaryCoords
								+ Set absolute pos
								+ Set absolute vel to (TrajectoryStartAbsoluteCoords - TrajectoryStartBaryCoords)/remainingDT
								+ Set mesh-relative vel to absolute vel with meshDisplacement
									+ Should take meshVelocity as arg, calculated @ beginning on whole DT
							+ Bounce:
								+ Calc how much of *trajectory* has been moving so far, and use that for remaining DT
								+ Set current bary coords to bary coords of intersection
								+ Set absolute pos
									- It's ok to change here: after bounce we can take mesh as moved already, and we only care about
									  physics delta pos from new position
										- Because now we have included mesh displacement in velocity (via bounce)
								+ Set absolute vel
								+ Set mesh-relative vel
								+ Verify/think following iterations in outer loop after this bounce
									+ Cut segment short
							+ Becoming free:
								+ Do whole free movement here, consuming whole dt
					+ NonInertial case
			+ Restructure loop now, to account for multiple on-edge loops:
				! TraceSegment either exits (completes), or moves currenty bary coords (and calcs remaining dt) when it wants to "continue" an impact while on edge-moving-against-it, i.e.
				  wants to recalculate a new flattened traj
					! Doesn't change current absolute pos, nor velocity
				+ In this case, at next iteration:
					+ TrajectoryStart (==current bary coords) is new
					+ TrajectoryEnd (==current absolute pos + physicsDeltaPos) is same as before
				+ Loop restructure:
					+ Free by itself
					+ Loop (else if constrained):
						+ See if DT really necessary - especially after Impact Continuation work below
	+ Impact continuation
		+ Mechanics:
			X Option 1:
				+ TraceSegment gets boolean to say if it's on an edge/non-inertial
				! If it's in non-inertial, the first trajectory intersection will be a) on same edge, and b) also on another edge (i.e. on a cuspid)
				! Potentially useful facts:
					- When non-inertial and tracing segment:
						- First hit with cuspid: t > 0, intersection b-coords are (1,0,0), with zero at original edge
						- Second hit with cuspid: t == 0, intersection b-coords are (1,0,0) - seems that it should be zero always at original edge
						- Third hit with cuspid: t == 0, intersection b-coords are (1,0,0) - seems that it should be zero always at original edge
						- Now it's a floor, and impact
				~ Algo:
					+ ...arrive at point where target is outside triangle
					+ Calculate intersection coords
					+ Move to intersection coords?
					! If non-inertial, we are on a floor edge
					+ If intersection is heads-on with a floor edge:
						! Here we normally declare "impact", as we by definition consider an intersection as being hit along the trajectory
						! This is the bump case
						+ If non-inertial:
							+ Check cross product with current trajectory (stand-in of edge)
								! Because if we're in non-inertial case, trajectory is flattened against origin edge, hence we can take its dir as being the edge dir
							+ If abs(cross product) < epsilon1 AND/OR TODO: walking condition/slow velocity:
								+ Do impact continuation:
									+ Update traveled trajectory distance
									+ Return dt (as a function of traveled distance)
								+ Test climbing over gentle slope - as opposed to bounce
									+ TODO: asymmetric now - L vs R, going R cos is < 0
										+ normals
							+ Else: below
						+ Else:
							+ Impact (& bounce)
					
					X Else:
						! Note: this includes along the floor (no bump), flying away over not an edge (to reach intersection on an edge), and cuspids
						+ If it's cuspid-cuspid intersection (t==0): maintain isNonInertial; climb over edge, ...
						X Else: if non-inertial and not first hit (or else we're always stuck with the first hit!): do impact continuation: 
						 (both "along the floor-no bump" and "flying away over not an edge" cases)
							+ Don't move current coords in this case
							+ Update traveled trajectory distance
							+ Return dt (as a function of traveled distance)
							X TODO: when reaching to point in triangle at non-first iter, we end up forcing next iteration to be inertial
							X TODO: cuspid is sometimes ~0.0, hence we do continuation from there and it's inertial
								X See if can clamp after detecting cuspid
							+ TODO: if TraceSegment starts on a cuspid, and traveling by t=0.0 makes it hit a floor, and slope is small, then we do continuation
							  consuming dt=0.0 => infinite loop
								+ Fix (to this and others above)" do custom TraceSegment at NonInertial
									+ With all the simplifications of knowing that we're on an edge, and on which
									+ Incorporate (re-simplified) TraceSegment into Inertial
							X Note: if we decide to only do continuation under condition (e.g. velocity being small, or slope), i.e. we continue, then we need to
							  distinguish between "along the floor-no bump" and "flying away over not an edge":
								X If "along the floor-no bump": we want to maintain isNonInertial, or else we might bump next (case of first hit, which is followed
								  by cuspids and then encounters floor on other triangle)
									X Found by checking that the same pair of coords has zero
										X And we assume it's the floor edge
								X If "flying away over not an edge": reset isNonInertial (we've decided not to do impact continuation, hence we leave the floor)
						X Else: ...
					
			+ Option 1b: two separate loops replacing TraceSegment
				+ 1: Copy what's needed from trace segment into inertial
					- Leave TraceSegment around for later
				+ 2: Do own loop into non-inertial
					+ Verify codepath at continuation, especially velocities
						+ Velocities are *all* calculated as (end abs - start abs) / LabParameters::DT
				+ Fix for infinite loop when distance traveled is zero:
					+ Detect previous, then interrupt						
						+ Redo 3 times no movement
						+ Set velocity to zero, and automatically relative velocity to mesh velocity				
				+ Extract bounce into helper method
				+ Tests:
					+ Well with bounce
					+ Climbing (impact continuation), both L and R
					+ Bouncing, both L and R
					+ Test flying off surface
					+ Relative velocity
						+ Fix ghost bounce: due to zeroing of vel at well
				X Test with refreshing trajectory at impact continuation
					+ Removes sudden well
					X ...but also might break "smooth slide" and make it bumpy again
				
	+ Re-instate dipole - w/out human
	+ Re-instate human state machine, w/out walking
	= Re-instate walking
		+ Step 1: restructure loops so that traj flattening happens in main loop
		+ Step 2: main loop initializes distanceToDisplaceInStep, distanceToWalkInStep, totalDistanceDisplaced
		+ Step 3: inner loop returns distanceDisplaced, outer loop calcs dt based off distance asked to displace in step and distanceDisplaced
		+ Step 4: undo: go back to simply calculating "displacementToWalk" (and "physicalDisplacement") separately at the beginning of each step, as a function of the current time quantum
			! Fact: at each iteration, the actual movement of the particle will be the result of phys traj and imposed walk displacement
				! Phys traj displacement is itself dependant from remaining_dt, because of advancement of particle's current bary coords
				! Walk displacement must be dependant from remaining_dt, for example by means of using walk velocity
			! Fact: so, the actual movement includes the consumed_dt's portion (fraction) of both phys traj and imposed walk
			+ Total signed distance traveled during a step - returned at impact continuation - is implicitly result of (signed_edge_phys_traveled + signed_edge_walked)
				+ 1. Make it return signed distance - so just keep track of signed distance
			+ consumed_dt fraction may be calculated as signed_edge_traveled_actual / signed_edge_traveled_planned
				+ signed_edge_traveled_actual = returned (signed_edge_phys_traveled + signed_edge_walked) (implicit)
				+ signed_edge_traveled_planned = (signed_edge_phys_traveled_planned + signed_edge_walked_planned)
					+ Recalc'd at each iteration, for the remaining dt
						+ Valid as long as signed_edge_walked_planned takes into account remaining dt
					+ signed_edge_walked_planned == walk_vector.dot(edgeDir)
				+ 2. Do the above
			+ final velocity cacl'n: we do (signed_edge_traveled_actual (implicit, simply on-edge traveled) - signed_edge_walked_actual) * edgeDir / this_dt
				! Note: at this moment we've reached the planned end of the iteration's sub-trajectory
				+ So, we can assume that signed_edge_traveled_actual == signed_edge_traveled_planned
					+ Verify (allowing for numerical slack)
				+ And in particular, we can assume that signed_edge_walked_actual == signed_edge_walked_planned
					+ Which needs now to be passed as an arg
				+ Verify that delta w/current is OK (once we're walking)
				+ Change vel calc algo to new now
		+ Fix issue 1: final velocity calc'n: has bump sometimes when crossing triangle
			! Due to trajectory (end) not taking into account walk; because of walk, we overshoot end and thus have to go back
			+ Attempt 1: 
				+ At each iteration: move endpoiny by total distance walked so far - ~equiv to not moving start by walked
					+ Even if this impacts floor check - let's see if this hurts
		X Step 5a: test with spring forces being calc'd at each particle
			+ Step 1:
				+ vec2f CalculatePhysicalForces(...)
				+ Impl like now
			X Step 2:
				X Move spring forces to it

		+ Step 5b: test with torque being a quantity on its own, and calc'd at secondary after primary has moved
			! If it works, we might not need to impart distance walked to secondary
			+ HumanState has EquilibriumTorqueTODO
				+ Calc'd as converging 1.0
				+ Reset at transitions out of Rising, Equlibrium, and Walking
			+ CalculatePhysicalForces() uses it to calculate torque, when sec'ry and it's human
			+ Cleanup code
			+ Fix: torque of sec'ry makes primary move
				+ Because of friction loss
					+ Try particle-specific friction, head being negligible and feet being majority (e.g. 10-90)
				+ Human friction rearc:
					+ Static & Kinetic friction in materials:
						+ Furniture
						+ Head
						+ Foot
					+ Use materials @ particle add
					+ Use NpcParticle::PhysicalProperties for mass everywhere
					+ LabParameters: the two (st + ki) become "multipliers"
		
		+ Step 6:
			+ Human state: walk==<face dir x, velocity_strength>
			+ Secondary displacement: sum of all signed_edge_walked_actual *as vectors*,
			  which in turn may be calculated as signed_edge_traveled_actual * (signed_edge_walked_planned / signed_edge_traveled_planned)
				+ If returned is zero, it's either because planned (total) was zero, or we've cut short 
					+ If planned (total) was zero then we've reached target - this step should have completed; however, for safety, we may assume this happens (returns zero when planned was zero)
						+ Do nothing, as we'll complete later on
					+ Else (i.e. we've cut short): since planned was non-zero and actual is zero, then walked now is also zero
				+ If returned is completed: actual walked is planned walked
			+ Also note that sec'ry displacement needs to be applied even when sec'ry particle is not in non-inertial mode
				+ Secondary displacement must also be handled by inertial case (as secondary might be inertial), complete with taking into account
				  walked in final velocity calculation
					- Simply pass totalEdgeWalkedActual (vector) to ConstrainedInertial, which discounts it
			+ Plan:
				+ NpcParticles: VoluntarySuperimposedDisplacement is to store the vector
					+ Reset at beginning of NPC simulation loop
				+ Primary stores totalEdgeWalkedActual into it at exit of constrained loop
				+ totalEdgeWalkedActual is initialized with this quantity (technically @ secondary)
				+ ConstrainedNonInertial discounts it from final velocity calc'n
				+ ConstrainedInertial discounts it from final velocity calc'n

		- Step 7:
			- See if torque is the one responsible for slight bend
				- Go back to calculating torque at HumanUpdate

	- Cleanups:
		- Nuke old "1" simulations and rename "2"
			- Watch out: there are methods in 1 that we still need; port those to 2 before nuking & renaming
		- NpcParticles:
			- Nuke all Voluntary buffers except ones we care about
		- HumanSimulation:
			- No need to reset VoluntarySuperimposedDisplacement if we clear whole buffer @ each loop
			- Rationalize transition code (which is repeated a ton of times)
		- Does reduced dt do anything?
		- Extract velocity calculation (if still needed) into helper method
		- Nuke imparted trajectory (tool and all)
		- Nuke step-by-step
		
	- Merge into master
	- Go back to solving walking reached injuction of two floors

	- Add plan for "staircases"
		- 1: floors can be marked as "stairs", and that is used in two places:
			- Bounce detection: when walking, no bounce regardless of slope (do continuation case)
				- Only when we're walking
			- Walk vector flattening: forcibly extend walk along edge, even if exactly orthogonal
			- Auto-build: when two three consecutive edges wind up to 360 degrees
		- 2: own triangles (and edges)
	- Add plan for "manholes"
		- Floor info is on Triangle, not on Spring