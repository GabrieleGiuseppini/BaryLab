- Walking rearc attempt:
	+ Step 1: replace voluntary displacement *superimposed* with normal force, on primary only
		+ Kinda work - but secondary acquires more velocity than primary, because primary has friction
	= Step 2: Merge CalculateTraj with StepSimulation
		= Each Update...() step moves a segment and sets velocity based on movement achieved in its remainingDt
		= Issue at ConstrainedSegmentMove:
			! If we hit edge before end of a trajectory which is completely due to mesh movement, the particle position
			  changes as it's a temporary one; at the next iteration, trajectory is zero hence we don't move
				! We should then not update particle position and continue with the loop
			= Solution option 1:
				! UpdateNpcParticle_ConstrainedTraceSegment2() works completely on bary coords - it updates them at each step; only sets position at end moments (when it has fully consumed time quantum)
					! Thoughts: UpdateNpcParticle_ConstrainedInertial2() recalculates each time target bary coords after physics delta pos (which, TODO: does it change or not? should not change
					  for the rest of this plan to work); the current bary coords change each time
				= Loop for deltaT
					+ Note: if we allow to loop over multiple constrained sub-loops, then meshDisplacement/Velocity calculated at first step - before various coords are changed - must be constant
					  for all the other sub-loops
					+ Case 1
					+ Case 2, 3 (Constrained): UpdateNpcParticle_ConstrainedTraceSegment2()
						+ Trajectory: first particles moves with mesh (start traj) and then we try to reach start abs pos + physics delta pos (which might be zero)
						+ Takes:
							+ TrajectoryStartBaryCoords (==current bary coords; once converted to absolute, are due exclusively to mesh displacement)
							+ (Start absolute coords are implicitly TrajectoryStartBaryCoords converted to absolute)
							+ TrajectoryEndBaryCoords (==bary coords (after mesh displacement) of startPos + physicsDeltaPos)
							+ TrajectoryEndAbsoluteCoords (==startPos + physicsDeltaPos)
							+ MeshDisplacement - but TODO: remaining portion? or whole?
						+ Loops until one of three exit conditions, at which point sets physics and calculates remaining DT
							+ Reaching destination:
								! We consume the whole time quantum
								+ Set CurrentBaryCoords to TrajectoryEndBaryCoords
								+ Set absolute pos
								+ Set absolute vel to (TrajectoryStartAbsoluteCoords - TrajectoryStartBaryCoords)/remainingDT
								+ Set mesh-relative vel to absolute vel with meshDisplacement
									+ Should take meshVelocity as arg, calculated @ beginning on whole DT
							+ Bounce:
								+ Calc how much of *trajectory* has been moving so far, and use that for remaining DT
								+ Set current bary coords to bary coords of intersection
								+ Set absolute pos
									- It's ok to change here: after bounce we can take mesh as moved already, and we only care about
									  physics delta pos from new position
										- Because now we have included mesh displacement in velocity (via bounce)
								+ Set absolute vel
								+ Set mesh-relative vel
								+ Verify/think following iterations in outer loop after this bounce
									+ Cut segment short
							+ Becoming free:
								+ Do whole free movement here, consuming whole dt
					- NonInertial case
					- Think: will multiple on-edge loops cause problems because of missing mesh displacement?
						- No, as long as:
							- Each loop does trajectory from TrajectoryStart (==current bary coords) to TrajectoryEnd (==current absolute pos + deltaPos)
								- TODOHERE: actually it's the ABS POS that we care about: trajectoryStartAbsolutePosition = current bary coords -> abs pos
							- And: at the end of each loop that is meant to continue we:
								- Update current bary coords to what will become the next TrajectoryStart
								- Do *NOT* update absolute pos
							- And: TrajectoryEnd remains constant from one loop iteration to the other
								- TODO: is this really necessary? And, if so, does it really hold?
					- Optimize:
						- current bary coords are in local var
							- set at exit points - where needed
						- current triangle is in local var
							- set at exit points - where needed

	- Re-instate dipole - w/out human
	- Re-instate human state machine, w/out walking
	- Re-instate walking
		- TODOHERE: still need to figure it out
		- First version: try with voluntaryVelocity (instead of displacement)
			- Set to purely walking velocity
			- But then, secondary trails primary, or doesn't follow it walking
				- Wanna try by forecasting primary when we calc walk vector at HumanWalkingStateMachine?
	- Cleanups:
		- Nuke old "1" simulations and rename "2"
		- Nuke imparted trajectory (tool and all)
		- Nuke step-by-step
	- Go back to solving walking reached injuction of two floors