= Verify elasticity & friction
	! TODO: at impact (during ray tracing), if we are on edge we do not update pos
	X Try fix 1:
		- At impact:
			- Set velocity to classic response (N+T)
			- If bounce is more than threshold:
				- Detach from edge by fixed epsilon
			- Else (bounce < threshold)				
				- Stay on edge
			- Return true
		- Then, at step beginning:
			- If on edge (implies we're constrained):
				- Total forces += (apparent forces)
				- When we'll integrate, we'll zero out gravity and apparent force (depending on normal), and also take eventual bounce velocity
			- Integrate
				- If on edge, we zero out gravity and apparent force (depending on normal) because of counter apparent forces
				- We also take the eventual bounce velocity acquired during impact
		- No more no-do on-edge case at RT
	X Try fix 2:
		- Move impact response to intersection finding, when that edge is floor and we go through it
		- At inital on edge, if we go through it: flatten trajectory
			- Replacing targets (so it's also rendered)
			- Replacing velocity
	= Try fix 3: at impact, after response we flatten trajectory
		- Fix issue when at vertex
		- Cleanup:
			- Code: do not mix local and state variables, given that we change target now
	- Try fix 4:
		- Branch first, reverting code - keeping this TODO!
		- At physics we detect being on an edge/vertex and we do physics trajectory accordingly
			- Flattening forces if on edge, doing TODO if on vertex
		- At RT, we become tolerant of trajectory being almost-parallel to edge, and continue RT when moving along edge
			- What do we do now if we are on edge and trajectory is strictly outside?
				- Should not happen at entry because of physics step; could it happen during RT though?
					- If it happens, we simply terminate - like old 
			- We also need to become tolerant to being on vertex, that's a bug that should have been already there
			- Also, impact (with response) only happens at real impact, i.e. when intersecting edge that is floor (& ghost condition)
				- We first move to edge, and then check floor+ghost and do normal response
				- TODO: what happens to the respone velocity? If we complete here, we'll end up being on edge and by definition we'll flatten, not bounce
					- However, if after response we bounce also trajectory and continue RT, we end up bouncing all the time and never terminating - hitting edge is our termination condition
					  for when target is unreachable
					- A possible way out is to ensure that after the bounce we are _not_ on an edge, e.g. by moving by epsilon OR by explicitly entering a "on edge but not on edge" state before
					  termination
					- Another way is to make sure in the physics step to figure out, when on edge, whether current velocity would make a bounce - and thus no "opposite apparent" - or not
	= Try fix 5 (Moleskine, holidays):
		= Consider alternative implementation:
			+ Elasticity (impact) done like now at edge
			- Apparent forces & friction done @ physics steps iff on edge
		+ FIX:
			+ When climbing edge @ vertex, we switch "edge we're on and thus want to ignore"  from climbed to other one, arbitrarily
			+ Fix: remove check for current edge, & find closest intersection among those that are *strictly* away from edge (i.e. towards traj)
		+ See if really need special handling for into-vertex
			+ Test it
				X Do model change with corner bottom-right
		+ FIX:
			+ Velocity used for calculating bounce response should be traj's, not current particle v's, as traj contains also apparent
				+ Do RayTracingState (see below), which contains:
					+ Whole traj (start, end)
					+ Render position
						+ This used for rendering when RayTracingState is present
				+ Particle's position is only changed at exits of UpdateParticleState
				+ At bounce:
					+ Use trajectory (divided by dt) as velocity
					+ No need to check velocity (against normal) anymore
			+ Rename "RayTracing" (as in Particle::State and as UpdateXXX member of controller) as "Trajectory"
		+ FIX: slowing down when on edge
			+ Hide trajectory
			+ Commit
			+ Multi-frame rendering
			+ Commit
			+ CalculatePhysicsTrajEnd calcs also target bary coords
			+ UpdateState: 
				+ Do not calc target bary coords
				+ Recalc them any time we change triangle
				X Recalc them any other time we change target coords
		+ FIX: when particle on vertex, we choose the wrong one at CalculatePhysicsTarget to check if we need to flatten
			+ Should check all and flatten on first
		+ FIX: initial coords calc'd at regime change are not always fully within boundaries
		+ FIX: even when in triangle, particle gains speed due to apparent velocity
			! Because at end of UpdateParticleState we set velocity to whole trajectory, which unfortunately also contains *apparent* travel
			+ When leaving UpdateParticleState because of completed trajectory: set velocity by *absolute* delta pos traveled (not by trajectory)
			+ When leaving UpdateParticleState because of impact: calculate incident velocity taking by full trajectory traveled
				+ See below: this *should* include distance traveled due to apparent wall push
		+ FIX: when on edge, particle does not acquire wall push
			! Technically absolute displacement would contain push, but here we override the final particle's velocity with *impact* velocity
			+ Aren't we flattening trajectory here?
				! No, because deltaPos is physics' and thus it's zero now
					! We need to take into account wall
				+ Should we then calc deltaPos based on "trajectory" (where triangle is now - (cur pos + target physics deltaPos)) and check that one instead?
					+ But then: case of velocity already there and mesh augmenting
					+ Fix: we should flattened deltaPos (after verifying traj is against wall)
		+ Friction & apparent forces:
			+ First, do moving mesh below
			! Note: when on edge, absolute delta pos traveled (thus not trajectory) after frame includes distance traveled due to apparent wall push
				! So: this must be the velocity that we set for the particle at the end
			+ Algo - when on floor:
				+ f1=Calc world forces
				+ f2=Friction: we calculate this when flattening
					+ Need to take into account both *relative* velocity and apparent wall forces; hence,
					  we calculate friction force by calculating Fn and Ft on entire *trajectory* *flattened*
					+ 1. Calculate Fn, Ft, and decide which friction takes place
						+ Use relative velocity to determine whether static or kinetic
					+ 2. Integrate friction (which is tangential hence already flattened) and add its effect to trajectory
				
				+ Make sure we set velocity to absolute delta pos traveled after the frame
		+ Cleanup CalculatePhysicsTarget
			+ Ain't Ft integrated the flattened trajectory? ain't all here doable in terms of displacements instead of forces
		- Fix bounce against moving wall (v=+3): transfer is too much
		

				
