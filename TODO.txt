- Walking rearc attempt:
	+ Step 1: replace voluntary displacement *superimposed* with normal force, on primary only
		+ Kinda work - but secondary acquires more velocity than primary, because primary has friction
	+ Step 2: Merge CalculateTraj with StepSimulation
		+ Each Update...() step moves a segment and sets velocity based on movement achieved in its remainingDt
		= Issue at ConstrainedSegmentMove:
			! If we hit edge before end of a trajectory which is completely due to mesh movement, the particle position
			  changes as it's a temporary one; at the next iteration, trajectory is zero hence we don't move
				! We should then not update particle position and continue with the loop
			+ Solution: UpdateNpcParticle_ConstrainedTraceSegment2() works completely on bary coords - it updates them at each step; only sets position at end moments (when it has fully consumed time quantum)
				! Thoughts: UpdateNpcParticle_ConstrainedInertial2() recalculates each time target bary coords after physics delta pos (which, TODO: does it change or not? should not change
				  for the rest of this plan to work); the current bary coords change each time
				+ Loop for deltaT
					+ Note: if we allow to loop over multiple constrained sub-loops, then meshDisplacement/Velocity calculated at first step - before various coords are changed - must be constant
					  for all the other sub-loops
					+ Case 1
					+ Case 2, 3 (Constrained): UpdateNpcParticle_ConstrainedTraceSegment2()
						+ Trajectory: first particles moves with mesh (start traj) and then we try to reach start abs pos + physics delta pos (which might be zero)
						+ Takes:
							+ TrajectoryStartBaryCoords (==current bary coords; once converted to absolute, are due exclusively to mesh displacement)
							+ (Start absolute coords are implicitly TrajectoryStartBaryCoords converted to absolute)
							+ TrajectoryEndBaryCoords (==bary coords (after mesh displacement) of startPos + physicsDeltaPos)
							+ TrajectoryEndAbsoluteCoords (==startPos + physicsDeltaPos)
							+ MeshDisplacement - but TODO: remaining portion? or whole?
						+ Loops until one of three exit conditions, at which point sets physics and calculates remaining DT
							+ Reaching destination:
								! We consume the whole time quantum
								+ Set CurrentBaryCoords to TrajectoryEndBaryCoords
								+ Set absolute pos
								+ Set absolute vel to (TrajectoryStartAbsoluteCoords - TrajectoryStartBaryCoords)/remainingDT
								+ Set mesh-relative vel to absolute vel with meshDisplacement
									+ Should take meshVelocity as arg, calculated @ beginning on whole DT
							+ Bounce:
								+ Calc how much of *trajectory* has been moving so far, and use that for remaining DT
								+ Set current bary coords to bary coords of intersection
								+ Set absolute pos
									- It's ok to change here: after bounce we can take mesh as moved already, and we only care about
									  physics delta pos from new position
										- Because now we have included mesh displacement in velocity (via bounce)
								+ Set absolute vel
								+ Set mesh-relative vel
								+ Verify/think following iterations in outer loop after this bounce
									+ Cut segment short
							+ Becoming free:
								+ Do whole free movement here, consuming whole dt
					+ NonInertial case
			+ Restructure loop now, to account for multiple on-edge loops:
				! TraceSegment either exits (completes), or moves currenty bary coords (and calcs remaining dt) when it wants to "continue" an impact while on edge-moving-against-it, i.e.
				  wants to recalculate a new flattened traj
					! Doesn't change current absolute pos, nor velocity
				+ In this case, at next iteration:
					+ TrajectoryStart (==current bary coords) is new
					+ TrajectoryEnd (==current absolute pos + physicsDeltaPos) is same as before
				+ Loop restructure:
					+ Free by itself
					+ Loop (else if constrained):
						+ See if DT really necessary - especially after Impact Continuation work below
	+ Impact continuation
		+ Mechanics:
			X Option 1:
				+ TraceSegment gets boolean to say if it's on an edge/non-inertial
				! If it's in non-inertial, the first trajectory intersection will be a) on same edge, and b) also on another edge (i.e. on a cuspid)
				! Potentially useful facts:
					- When non-inertial and tracing segment:
						- First hit with cuspid: t > 0, intersection b-coords are (1,0,0), with zero at original edge
						- Second hit with cuspid: t == 0, intersection b-coords are (1,0,0) - seems that it should be zero always at original edge
						- Third hit with cuspid: t == 0, intersection b-coords are (1,0,0) - seems that it should be zero always at original edge
						- Now it's a floor, and impact
				~ Algo:
					+ ...arrive at point where target is outside triangle
					+ Calculate intersection coords
					+ Move to intersection coords?
					! If non-inertial, we are on a floor edge
					+ If intersection is heads-on with a floor edge:
						! Here we normally declare "impact", as we by definition consider an intersection as being hit along the trajectory
						! This is the bump case
						+ If non-inertial:
							+ Check cross product with current trajectory (stand-in of edge)
								! Because if we're in non-inertial case, trajectory is flattened against origin edge, hence we can take its dir as being the edge dir
							+ If abs(cross product) < epsilon1 AND/OR TODO: walking condition/slow velocity:
								+ Do impact continuation:
									+ Update traveled trajectory distance
									+ Return dt (as a function of traveled distance)
								+ Test climbing over gentle slope - as opposed to bounce
									+ TODO: asymmetric now - L vs R, going R cos is < 0
										+ normals
							+ Else: below
						+ Else:
							+ Impact (& bounce)
					
					X Else:
						! Note: this includes along the floor (no bump), flying away over not an edge (to reach intersection on an edge), and cuspids
						+ If it's cuspid-cuspid intersection (t==0): maintain isNonInertial; climb over edge, ...
						X Else: if non-inertial and not first hit (or else we're always stuck with the first hit!): do impact continuation: 
						 (both "along the floor-no bump" and "flying away over not an edge" cases)
							+ Don't move current coords in this case
							+ Update traveled trajectory distance
							+ Return dt (as a function of traveled distance)
							X TODO: when reaching to point in triangle at non-first iter, we end up forcing next iteration to be inertial
							X TODO: cuspid is sometimes ~0.0, hence we do continuation from there and it's inertial
								X See if can clamp after detecting cuspid
							+ TODO: if TraceSegment starts on a cuspid, and traveling by t=0.0 makes it hit a floor, and slope is small, then we do continuation
							  consuming dt=0.0 => infinite loop
								+ Fix (to this and others above)" do custom TraceSegment at NonInertial
									+ With all the simplifications of knowing that we're on an edge, and on which
									+ Incorporate (re-simplified) TraceSegment into Inertial
							X Note: if we decide to only do continuation under condition (e.g. velocity being small, or slope), i.e. we continue, then we need to
							  distinguish between "along the floor-no bump" and "flying away over not an edge":
								X If "along the floor-no bump": we want to maintain isNonInertial, or else we might bump next (case of first hit, which is followed
								  by cuspids and then encounters floor on other triangle)
									X Found by checking that the same pair of coords has zero
										X And we assume it's the floor edge
								X If "flying away over not an edge": reset isNonInertial (we've decided not to do impact continuation, hence we leave the floor)
						X Else: ...
					
			+ Option 1b: two separate loops replacing TraceSegment
				+ 1: Copy what's needed from trace segment into inertial
					- Leave TraceSegment around for later
				+ 2: Do own loop into non-inertial
					+ Verify codepath at continuation, especially velocities
						+ Velocities are *all* calculated as (end abs - start abs) / LabParameters::DT
				+ Fix for infinite loop when distance traveled is zero:
					+ Detect previous, then interrupt						
						+ Redo 3 times no movement
						+ Set velocity to zero, and automatically relative velocity to mesh velocity				
				+ Extract bounce into helper method
				+ Tests:
					+ Well with bounce
					+ Climbing (impact continuation), both L and R
					+ Bouncing, both L and R
					+ Test flying off surface
					+ Relative velocity
						+ Fix ghost bounce: due to zeroing of vel at well
				X Test with refreshing trajectory at impact continuation
					+ Removes sudden well
					X ...but also might break "smooth slide" and make it bumpy again
				
	- Re-instate dipole - w/out human
	- Re-instate human state machine, w/out walking
	- Re-instate walking
		- Principles:
			- Walk vector - splattered along edge - is added to end position
				- During loop, current pos changes and gets closer and closer - that's how we make progress
			- This displacement is added to secondary particle
			- This displacement is given to func as ~velocityToDiscount, albeit it's mesh-relative
		- TODOOLD:
		- Imparting displacement to secondary:
			- Try: if walking, secondary end position is calculated based on primary, not based on secondary's physics
		- Discount velocity: by passing to TraceSegment - via non-inertial case, which knows it flattened - ~velocityToDiscount, calc'd along abs_start->abs_end dir
		- TODOHERE: still need to figure it out
			- how about: track total edge walked during tracing - use that to a) avoid gaining vel, b) knowing when to stop in the face of multiple segments
		- OLD
		- First version: try with voluntaryVelocity (instead of displacement)
			- Set to purely walking velocity
			- But then, secondary trails primary, or doesn't follow it walking
				- Wanna try by forecasting primary when we calc walk vector at HumanWalkingStateMachine?
	- Cleanups:
		- Does reduced dt do anything?
		- Extract velocity calculation (if still needed) into helper method
		- Nuke old "1" simulations and rename "2"
		- Nuke imparted trajectory (tool and all)
		- Nuke step-by-step
	- Merge into master
	- Go back to solving walking reached injuction of two floors

	- Add plan for "staircases"
		- 1: floors can be marked as "stairs", and that is used in two places:
			- Bounce detection: when walking, no bounce regardless of slope (do continuation case)
				- Only when we're walking
			- Walk vector flattening: forcibly extend walk along edge, even if exactly orthogonal
			- Auto-build: when two three consecutive edges wind up to 360 degrees
		- 2: own triangles (and edges)
	- Add plan for "manholes"
		- Floor info is on Triangle, not on Spring