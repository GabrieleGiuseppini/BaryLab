- Walking rearc attempt:
	+ Step 1: replace voluntary displacement *superimposed* with normal force, on primary only
		+ Kinda work - but secondary acquires more velocity than primary, because primary has friction
	= Step 2: Merge CalculateTraj with StepSimulation
		+ Each Update...() step moves a segment and sets velocity based on movement achieved in its remainingDt
		= Issue at ConstrainedSegmentMove:
			! If we hit edge before end of a trajectory which is completely due to mesh movement, the particle position
			  changes as it's a temporary one; at the next iteration, trajectory is zero hence we don't move
				! We should then not update particle position and continue with the loop
			+ Solution: UpdateNpcParticle_ConstrainedTraceSegment2() works completely on bary coords - it updates them at each step; only sets position at end moments (when it has fully consumed time quantum)
				! Thoughts: UpdateNpcParticle_ConstrainedInertial2() recalculates each time target bary coords after physics delta pos (which, TODO: does it change or not? should not change
				  for the rest of this plan to work); the current bary coords change each time
				+ Loop for deltaT
					+ Note: if we allow to loop over multiple constrained sub-loops, then meshDisplacement/Velocity calculated at first step - before various coords are changed - must be constant
					  for all the other sub-loops
					+ Case 1
					+ Case 2, 3 (Constrained): UpdateNpcParticle_ConstrainedTraceSegment2()
						+ Trajectory: first particles moves with mesh (start traj) and then we try to reach start abs pos + physics delta pos (which might be zero)
						+ Takes:
							+ TrajectoryStartBaryCoords (==current bary coords; once converted to absolute, are due exclusively to mesh displacement)
							+ (Start absolute coords are implicitly TrajectoryStartBaryCoords converted to absolute)
							+ TrajectoryEndBaryCoords (==bary coords (after mesh displacement) of startPos + physicsDeltaPos)
							+ TrajectoryEndAbsoluteCoords (==startPos + physicsDeltaPos)
							+ MeshDisplacement - but TODO: remaining portion? or whole?
						+ Loops until one of three exit conditions, at which point sets physics and calculates remaining DT
							+ Reaching destination:
								! We consume the whole time quantum
								+ Set CurrentBaryCoords to TrajectoryEndBaryCoords
								+ Set absolute pos
								+ Set absolute vel to (TrajectoryStartAbsoluteCoords - TrajectoryStartBaryCoords)/remainingDT
								+ Set mesh-relative vel to absolute vel with meshDisplacement
									+ Should take meshVelocity as arg, calculated @ beginning on whole DT
							+ Bounce:
								+ Calc how much of *trajectory* has been moving so far, and use that for remaining DT
								+ Set current bary coords to bary coords of intersection
								+ Set absolute pos
									- It's ok to change here: after bounce we can take mesh as moved already, and we only care about
									  physics delta pos from new position
										- Because now we have included mesh displacement in velocity (via bounce)
								+ Set absolute vel
								+ Set mesh-relative vel
								+ Verify/think following iterations in outer loop after this bounce
									+ Cut segment short
							+ Becoming free:
								+ Do whole free movement here, consuming whole dt
					+ NonInertial case
			= Restructure loop now, to account for multiple on-edge loops:
				! TraceSegment either exits (completes), or moves currenty bary coords (and calcs remaining dt) when it wants to "continue" an impact while on edge-moving-against-it, i.e.
				  wants to recalculate a new flattened traj
					! Doesn't change current absolute pos, nor velocity
				+ In this case, at next iteration:
					+ TrajectoryStart (==current bary coords) is new
					+ TrajectoryEnd (==current absolute pos + physicsDeltaPos) is same as before
				= Loop restructure:
					+ Free by itself
					= Loop (else if constrained):
						- See if DT really necessary - especially after Impact Continuation work below
	= Impact continuation
		= Mechanics:
			= Option 1:
				+ TraceSegment gets boolean to say if it's on an edge/non-inertial
				! If it's in non-inertial, the first trajectory intersection will be a) on same edge, and b) also on another edge (i.e. on a cuspid)
				! Potentially useful facts:
					- When non-inertial and tracing segment:
						- First hit with cuspid: t > 0, intersection b-coords are (1,0,0), with zero at original edge
						- Second hit with cuspid: t == 0, intersection b-coords are (1,0,0) - seems that it should be zero always at original edge
						- Third hit with cuspid: t == 0, intersection b-coords are (1,0,0) - seems that it should be zero always at original edge
						- Now it's a floor, and impact
				= Algo:
					- Traveled distance in this segment = 0.0
					+ ...arrive at point where target is outside triangle
					+ Calculate intersection coords
					! If non-inertial, we are on a floor edge
					- If intersection is heads-on with a floor edge:
						! Here we normally declare "impact", as we by definition consider an intersection as being hit along the trajectory
						! This is the bump case
						- If non-inertial:
							- Check cross product with current trajectory (stand-in of edge)
								! Because if we're in non-inertial case, trajectory is flattened against origin edge, hence we can take its dir as being the edge dir
							- If abs(cross product) < epsilon1 OR TODO: walking condition/slow velocity:
								- Do impact continuation:
									- Update traveled distance
									- Return dt (as a function of traveled distance)
							- Else: below
						- Else:
							- Impact (& bounce)
					- Else:
						! Note: this includes along the floor (no bump), flying away over not an edge (to reach intersection on an edge), and cuspids
						- If it's cuspid-cuspid intersection (t==0): maintain isNonInertial; climb over edge, ...
						- If non-inertial: do impact continuation:
							- Update traveled distance
							- Return dt (as a function of traveled distance)
						- Else: ...

			- Option 2 (old):
				- TraceSegment: mutable arg "raking"edgeOrdinal tells us whether we're on edge (-1 if not)
				- After calculating intersection, we check if it's still on (carried over) edge
					- It is if same ordinal vertex is still zero
				- If Impact: decide continuation by using current "raking"edgeOrdinal
					- TODO: isn't enough to relax tolerance to dot product in current algo?
				- Else: TODO: see if could being onto an edge with minimal slope
				- TODO: consider alternative: when changing triangle *and in non-inertial case*, return immediately - so that we recalc traj and flatten on new floor
	- Re-instate dipole - w/out human
	- Re-instate human state machine, w/out walking
	- Re-instate walking
		- TODOHERE: still need to figure it out
			- how about: track total edge walked during tracing - use that to a) avoid gaining vel, b) knowing when to stop in the face of multiple segments
		- First version: try with voluntaryVelocity (instead of displacement)
			- Set to purely walking velocity
			- But then, secondary trails primary, or doesn't follow it walking
				- Wanna try by forecasting primary when we calc walk vector at HumanWalkingStateMachine?
	- Cleanups:
		- Nuke old "1" simulations and rename "2"
		- Nuke imparted trajectory (tool and all)
		- Nuke step-by-step
	- Go back to solving walking reached injuction of two floors