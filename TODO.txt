= Verify elasticity & friction
	! TODO: at impact (during ray tracing), if we are on edge we do not update pos
	X Try fix 1:
		- At impact:
			- Set velocity to classic response (N+T)
			- If bounce is more than threshold:
				- Detach from edge by fixed epsilon
			- Else (bounce < threshold)				
				- Stay on edge
			- Return true
		- Then, at step beginning:
			- If on edge (implies we're constrained):
				- Total forces += (apparent forces)
				- When we'll integrate, we'll zero out gravity and apparent force (depending on normal), and also take eventual bounce velocity
			- Integrate
				- If on edge, we zero out gravity and apparent force (depending on normal) because of counter apparent forces
				- We also take the eventual bounce velocity acquired during impact
		- No more no-do on-edge case at RT
	X Try fix 2:
		- Move impact response to intersection finding, when that edge is floor and we go through it
		- At inital on edge, if we go through it: flatten trajectory
			- Replacing targets (so it's also rendered)
			- Replacing velocity
	= Try fix 3: at impact, after response we flatten trajectory
		- Fix issue when at vertex
		- Cleanup:
			- Code: do not mix local and state variables, given that we change target now
	- Try fix 4:
		- Branch first, reverting code - keeping this TODO!
		- At physics we detect being on an edge/vertex and we do physics trajectory accordingly
			- Flattening forces if on edge, doing TODO if on vertex
		- At RT, we become tolerant of trajectory being almost-parallel to edge, and continue RT when moving along edge
			- What do we do now if we are on edge and trajectory is strictly outside?
				- Should not happen at entry because of physics step; could it happen during RT though?
					- If it happens, we simply terminate - like old 
			- We also need to become tolerant to being on vertex, that's a bug that should have been already there
			- Also, impact (with response) only happens at real impact, i.e. when intersecting edge that is floor (& ghost condition)
				- We first move to edge, and then check floor+ghost and do normal response
				- TODO: what happens to the respone velocity? If we complete here, we'll end up being on edge and by definition we'll flatten, not bounce
					- However, if after response we bounce also trajectory and continue RT, we end up bouncing all the time and never terminating - hitting edge is our termination condition
					  for when target is unreachable
					- A possible way out is to ensure that after the bounce we are _not_ on an edge, e.g. by moving by epsilon OR by explicitly entering a "on edge but not on edge" state before
					  termination
					- Another way is to make sure in the physics step to figure out, when on edge, whether current velocity would make a bounce - and thus no "opposite apparent" - or not
	= Try fix 5 (Moleskine, holidays):
		= Consider alternative implementation:
			+ Elasticity (impact) done like now at edge
			- Apparent forces & friction done @ physics steps iff on edge
		+ FIX:
			+ When climbing edge @ vertex, we switch "edge we're on and thus want to ignore"  from climbed to other one, arbitrarily
			+ Fix: remove check for current edge, & find closest intersection among those that are *strictly* away from edge (i.e. towards traj)
		+ See if really need special handling for into-vertex
			+ Test it
				X Do model change with corner bottom-right
		+ FIX:
			+ Velocity used for calculating bounce response should be traj's, not current particle v's, as traj contains also apparent
				+ Do RayTracingState (see below), which contains:
					+ Whole traj (start, end)
					+ Render position
						+ This used for rendering when RayTracingState is present
				+ Particle's position is only changed at exits of UpdateParticleState
				+ At bounce:
					+ Use trajectory (divided by dt) as velocity
					+ No need to check velocity (against normal) anymore
			+ Rename "RayTracing" (as in Particle::State and as UpdateXXX member of controller) as "Trajectory"
		+ FIX: slowing down when on edge
			+ Hide trajectory
			+ Commit
			+ Multi-frame rendering
			+ Commit
			+ CalculatePhysicsTrajEnd calcs also target bary coords
			+ UpdateState: 
				+ Do not calc target bary coords
				+ Recalc them any time we change triangle
				X Recalc them any other time we change target coords
		+ FIX: when particle on vertex, we choose the wrong one at CalculatePhysicsTarget to check if we need to flatten
			+ Should check all and flatten on first
		+ FIX: initial coords calc'd at regime change are not always fully within boundaries
		- Friction & apparent forces:
			- First, do moving mesh
			- TODOHERE: Take into consideration *relative* velocity
		

				


= Allow for moving mesh
	+ Particles::State: TargetPos becomes non-opt member of opt RayTracingState
		+ Presence of RayTracingState tells we're doing ray tracing instead of physics, in place of old TargetPos
	+ RayTracingState contains CurrentPosition - not absolute but in mesh coords
		+ Initialized - in constrained state - as current pos in triangle (we should be doing that already), and target as absolute target pos (should be doing that already)
			+ Do it also at manually-set case
		+ Particle's physical position is only set at end of particle update
			+ Set to RayTracingState::CurrentPosition
				+ Rationale: when we hit end of particle update, RayTracingState::CurrentPosition is either target position (and thus absolute),
				  or - when hitting edge - at new mesh's edge position
		+ Render:
			+ At each Render call, if we are doing RayTracing, render an additional ("shadow") particle at RayTracingState::CurrentPosition, almost transparent
				+ Real particle will move at end, and ghost disappears because of losing RayTracing state
	= Mesh Transformation UI:
		= Rotation: new tool
			+ No LabController member, acts directly
		- Velocity:
			- Store just vel, update whole mesh at UpdateMeshTransformations
				- Nuke "current translation"
		- UI:
			= Checkbox for "render RT" 
			- Two sliders (H/V)
				- Copy H/V slider flags code from FS
	- Rendering of mesh wrt speed: TODO
